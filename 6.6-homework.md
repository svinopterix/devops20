# 6.6 Troubleshooting
## 1

Получаем перечень операций, которые выполняются долльше 180 секунд
<pre>
use admin
db.aggregate([ { $currentOp: { allUsers: true, localOps: true } }, { $match: { secs_running: { $gte: 180 } } }])
</pre>
Получаем opid нужной операции, и завершаем её:
<pre>
db.killOp("OPID")
</pre>
Чтобы ограничить время выполнения операций, можно использовать метод maxTimeMS() при запуске операций, которые могут выполняться слишком долго.

## 2
Можно предположить, что число истекших ключей слишком велико. В случае если активный алгоритм истечения ключей обнаруживает, что из выборки 25% или более ключей истекли, он продолжает экспайрить ключи пока их доля не упадёт ниже 25%. Т.к. Redis однопоточный, это может замедлить или блокировать другие операции. В описанной ситуации можно попробовать увеличить число ключей, которые экспайрятся за один проход алгоритма:<br>
CONFIG SET ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 30

## 3
Ошибка 2013: Lost connection to MySQL server during query говорит о том, что соединение с сервером было разорвано в процессе ожидания результата запроса. Это может быть связано либо с падением сервера, либо с таймаутом соединения из-за возросшей нагрузки. Надо проверить оба варианта. Но факты, что по условиям задачи 1) частота этих проблем растёт с ростом нагрузки, и 2) т.к. гис-система, вероятно, объем возвращаемых данных по каждому запросу велик - говорят в пользу таймаутов соединения. Я бы попробовал увеличить net_read_timeout и connect_timeout.

## 4
Сообщение postmaster invoked oom-killer означает, что на сервере исчерпалась память и linux-механизм OOM Killer начал её принудительную очистку. Под раздачу попал процесс postmaster, принимающий входящие подключения клиентов СУБД, поэтому СУБД стала недоступной. Нужно разобраться в причинах исчерпания памяти - с помощью мониторинга или подручных средств (top, ps). Если это PostgreSQL её сжирает, то ограничить потребление им памяти, например, начать с анализа значений effective_cache_size и shared_buffers.
